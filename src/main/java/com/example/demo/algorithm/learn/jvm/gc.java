package com.example.demo.algorithm.learn.jvm;
/**
 * java的gc
 * 1、计数  每被引用一次就++ 这样的无法解决循环引用
 * 定义一系列的GCRoots  判断对象是否可达 (可达性分析)
 * 虚拟机栈(栈帧中的本地变量表)中引用的对象
 * 本地方法栈(Native 方法)中引用的对象方法区中类静态属性引用的对象
 * JNI（Java Native Interface）引用的对象
 * 方法区中常量 静态变量
 * 所有被同步锁持有的对象
 */

//程序计数器：线程私有的，是一块很小的内存空间，作为当前线程的行号器，用于记录当前虚拟机正在执行的线程指令地址
//虚拟机栈：线程私有的，每个方法执行的时候都会创建一个栈帧，用于存储局部变量表、操作数、动态链接和方法返回等信息，当线程请求的栈深度超过了虚拟机允许的最大深度时，就会抛出 StackOverFlowError
//本地方法栈：线程私有的，保存的是 native 方法的信息，当一个 jvm 创建的线程调用 native 方法后，
//jvm 不会在虚拟机栈中为该线程创建栈帧，而是简单的动态链接并直接调用该方法
//堆：java 堆是所有线程共享的一块内存，几乎所有对象的实例和数组都要在堆上分配内存，因此该区域经常发生垃圾回收的操作
//方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据

//	Java中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄露。如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露

//加载->连接->初始化。连接过程又可分为三步：验证->准备->解析。
//		通过全类名获取定义此类的二进制字节流。
//		将字节流所代表的静态存储结构转换为方法区的运行时数据结构。
//		在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口。
//	准备阶段是正式为类变量分配内存并设置类变量初始值的阶段

//	spi api
	//继承thread 实现Runnable Callable接口 使用线程池

//最大的区别，runnable没有返回值，而实现callable接口的任务线程能返回执行结果
//callable接口实现类中的run方法允许异常向上抛出，可以在内部处理，try catch，
//		但是runnable接口实现类中run方法的异常必须在内部处理，不能抛出

//	JMM(Java 内存模型)主要定义了对于一个共享变量，
//	当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。
// 分为主内存  线程的本地内存
//	利用缓存和改变执行代码顺序达到程序执行效率优化。

//volatile
//当一个变量被声明为 volatile 时：
//
//		线程在【读取】共享变量时，会先清空本地内存变量值，再从主内存获取最新值
//		线程在【写入】共享变量时，不会把值缓存在寄存器或其他地方（就是刚刚说的所谓的「工作内存」），而是会把值刷新回主内


	//volatile是非阻塞的 不能保证原子性  synchronized 可以保证原子性
//	如果写入变量值不依赖变量当前值，那么就可以用 volatile



//	任务提交：当一个外部任务（通常是一个实现了Runnable接口的对象）提交给线程池后，它首先会被存放在一个任务队列中。这个队列也被称为工作队列。
//			任务执行：线程池中的工作线程会不断地从任务队列中取出待处理任务并执行。如果所有的线程都在忙，新来的任务就会等待在任务队列中。
//			线程的复用：一旦线程完成了任务的执行，它会返回到线程池中，然后开始处理下一个等待在队列中的任务。这种方式有效地重复使用了线程，避免了频繁创建和销毁线程带来的性能开销。
//			线程池关闭：当不再需要线程池时，可以调用其shutdown()或shutdownNow()方法来关闭线程池。这会等待正在执行的任务完成，然后关闭线程池。需要注意的是，shutdownNow()会试图立即停止所有正在执行的任务，然后关闭线程池。

public class gc {
}
